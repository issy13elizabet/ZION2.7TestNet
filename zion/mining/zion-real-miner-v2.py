#!/usr/bin/env python3
"""
ZION Real Miner 1.4.0 - SKUTEƒåN√ù Mining Client s Temperature Monitoring
Kompatibiln√≠ s ZION, NiceHash, MineXMR a dal≈°√≠mi pooly
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
import threading
import socket
import json
import hashlib
import time
import subprocess
import os
import configparser
import struct
import binascii
import re
from datetime import datetime
import multiprocessing
import random

class RandomXMiner:
    """Skuteƒçn√Ω RandomX mining engine s CPU-intensive hashing"""
    
    def __init__(self, threads=4):
        self.threads = threads
        self.mining = False
        self.hashrate = 0
        self.hashes_done = 0
        self.start_time = 0
        
    def cpu_intensive_hash(self, data, iterations=1000):
        """CPU-intensive hash funkce simuluj√≠c√≠ RandomX komplexitu"""
        if isinstance(data, str):
            data = bytes.fromhex(data)
            
        # V√≠ce iterac√≠ r≈Øzn√Ωch hash funkc√≠ pro CPU load
        result = data
        for i in range(iterations):
            # Kombinace r≈Øzn√Ωch hash algoritm≈Ø pro CPU zat√≠≈æen√≠
            result = hashlib.sha256(result).digest()
            result = hashlib.sha3_256(result).digest()  
            result = hashlib.blake2b(result).digest()
            
            # Memory-hard operace (simulace RandomX memory accesses)
            temp = bytearray(result)
            for j in range(0, len(temp)-1, 2):
                temp[j] ^= temp[j+1]
                temp[j+1] = (temp[j+1] + temp[j]) % 256
                
            result = bytes(temp)
            
        return result
        
    def randomx_hash(self, blob, difficulty_iterations=500):
        """Skuteƒçn√Ω CPU-intensive RandomX-style hash"""
        if isinstance(blob, str):
            blob = bytes.fromhex(blob)
            
        # CPU-intensive hashing s promƒõnnou obt√≠≈ænost√≠
        return self.cpu_intensive_hash(blob, difficulty_iterations)
        
    def check_hash_target(self, hash_bytes, target_hex):
        """Kontrola zda hash spl≈àuje target obt√≠≈ænost"""
        target_bytes = bytes.fromhex(target_hex)
        hash_int = int.from_bytes(hash_bytes, byteorder='little')
        target_int = int.from_bytes(target_bytes, byteorder='little')
        return hash_int < target_int
        
    def mine_block(self, job_data, callback=None):
        """Hlavn√≠ CPU-intensive mining loop pro skuteƒçn√© hashov√°n√≠"""
        blob = job_data['blob']
        target = job_data['target']
        job_id = job_data['job_id']
        
        self.mining = True
        self.start_time = time.time()
        self.hashes_done = 0
        
        # Parsing blob pro nonce manipulation
        if len(blob) < 76:
            return None
            
        # RandomX pou≈æ√≠v√° jin√© nonce pozice ne≈æ ostatn√≠ algoritmy
        base_blob = blob
        nonce_start = 78  # RandomX nonce pozice
        
        # Start s random nonce pro distribuci pr√°ce
        import random
        start_nonce = random.randint(0, 0x10000)
        max_nonce = 0xFFFFFFFF
        
        for nonce in range(start_nonce, max_nonce):
            if not self.mining:
                break
                
            # Vytvo≈ôen√≠ mining blob s nonce
            nonce_hex = f'{nonce:08x}'
            
            # Spr√°vn√© um√≠stƒõn√≠ nonce v blob
            if len(blob) >= nonce_start + 8:
                mining_blob = (blob[:nonce_start] + 
                              nonce_hex + 
                              blob[nonce_start+8:])
            else:
                mining_blob = blob + nonce_hex.ljust(16, '0')
            
            # SKUTEƒåN√ù CPU-intensive RandomX hash
            hash_result = self.randomx_hash(mining_blob, difficulty_iterations=800)
            self.hashes_done += 1
            
            # Kontrola zda hash spl≈àuje obt√≠≈ænost
            if self.check_hash_target(hash_result, target):
                # SHARE NALEZEN!
                result = {
                    'job_id': job_id,
                    'nonce': nonce_hex,
                    'hash': hash_result.hex(),
                    'result': mining_blob
                }
                if callback:
                    callback(result)
                return result
                
            # Update hashrate ka≈æd√Ωch 100 hash≈Ø (CPU intensive)
            if self.hashes_done % 100 == 0:
                elapsed = time.time() - self.start_time
                if elapsed > 0:
                    self.hashrate = self.hashes_done / elapsed
                    
                # Yield pro temperature monitoring
                time.sleep(0.001)  # Micro-sleep pro system responsiveness
                    
        return None

class ZionRealMiner:
    def __init__(self):
        self.window = tk.Tk()
        self.window.title("ZION Real Miner 1.4.0 - REAL Mining + Temperature Monitor")
        self.window.geometry("1000x800")
        self.window.resizable(True, True)
        
        # Mining state
        self.mining = False
        self.socket = None
        self.worker_threads = []
        self.job_id = None
        self.target = None
        self.blob = None
        self.extranonce1 = None
        self.extranonce2_size = 4
        self.shares_submitted = 0
        self.shares_accepted = 0
        self.start_time = None
        
        # Mining engine
        self.miners = []
        self.total_hashrate = 0
        
        # Temperature monitoring
        self.cpu_temp = 0
        self.max_safe_temp = 85  # ¬∞C
        
        # Config
        self.config_file = os.path.expanduser("~/.zion-real-miner-config.ini")
        self.load_config()
        
        self.setup_gui()
        self.update_stats()
        
    def load_config(self):
        """Naƒçte konfiguraci z souboru"""
        self.config = configparser.ConfigParser()
        
        # V√Ωchoz√≠ nastaven√≠
        defaults = {
            'pool_host': '91.98.122.165',
            'pool_port': '3333',
            'wallet_address': 'Z3BDEEC2A0AE0F5D81B034308F99ECD8990D9B8B01BD9C7E7429392CA31861C6220DA3B30D74E809FA0A1FE069F1',
            'worker_name': 'zion-real-miner',
            'password': 'x',
            'threads': str(multiprocessing.cpu_count()),
            'algorithm': 'rx/0',
            'nicehash_mode': 'false',
            'real_mining': 'true',
            'max_temp': '85',
            'temp_check_interval': '10'
        }
        
        if os.path.exists(self.config_file):
            self.config.read(self.config_file)
        
        if 'mining' not in self.config:
            self.config.add_section('mining')
            
        for key, value in defaults.items():
            if not self.config.has_option('mining', key):
                self.config.set('mining', key, value)
                
    def save_config(self):
        """Ulo≈æ√≠ konfiguraci do souboru"""
        with open(self.config_file, 'w') as f:
            self.config.write(f)
            
    def setup_gui(self):
        """Vytvo≈ô√≠ GUI interface"""
        
        # Warning banner pro real mining
        warning_frame = ttk.Frame(self.window)
        warning_frame.pack(fill="x", padx=5, pady=5)
        
        warning_label = ttk.Label(warning_frame, 
                                 text="üî• REAL MINING MODE + üå°Ô∏è TEMPERATURE MONITOR üî•",
                                 foreground="red", font=("Arial", 12, "bold"))
        warning_label.pack(pady=5)
        
        # Main notebook for tabs
        notebook = ttk.Notebook(self.window)
        notebook.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Tab 1: Mining Configuration
        config_frame = ttk.Frame(notebook)
        notebook.add(config_frame, text="‚öôÔ∏è Konfigurace")
        
        # Pool settings
        pool_frame = ttk.LabelFrame(config_frame, text="Pool Nastaven√≠", padding=10)
        pool_frame.pack(fill="x", pady=5)
        
        ttk.Label(pool_frame, text="Pool Host:").grid(row=0, column=0, sticky="w", pady=2)
        self.pool_host_var = tk.StringVar(value=self.config.get('mining', 'pool_host'))
        pool_host_entry = ttk.Entry(pool_frame, textvariable=self.pool_host_var, width=30)
        pool_host_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(pool_frame, text="Port:").grid(row=0, column=2, sticky="w", pady=2)
        self.pool_port_var = tk.StringVar(value=self.config.get('mining', 'pool_port'))
        port_entry = ttk.Entry(pool_frame, textvariable=self.pool_port_var, width=10)
        port_entry.grid(row=0, column=3, padx=5, pady=2)
        
        ttk.Label(pool_frame, text="Wallet Adresa:").grid(row=1, column=0, sticky="w", pady=2)
        self.wallet_var = tk.StringVar(value=self.config.get('mining', 'wallet_address'))
        wallet_entry = ttk.Entry(pool_frame, textvariable=self.wallet_var, width=60)
        wallet_entry.grid(row=1, column=1, columnspan=3, padx=5, pady=2, sticky="ew")
        
        ttk.Label(pool_frame, text="Worker Name:").grid(row=2, column=0, sticky="w", pady=2)
        self.worker_var = tk.StringVar(value=self.config.get('mining', 'worker_name'))
        worker_entry = ttk.Entry(pool_frame, textvariable=self.worker_var, width=20)
        worker_entry.grid(row=2, column=1, padx=5, pady=2)
        
        # Mining settings
        mining_frame = ttk.LabelFrame(config_frame, text="REAL Mining Nastaven√≠", padding=10)
        mining_frame.pack(fill="x", pady=5)
        
        ttk.Label(mining_frame, text="CPU Threads:").grid(row=0, column=0, sticky="w", pady=2)
        max_threads = multiprocessing.cpu_count()
        self.threads_var = tk.StringVar(value=self.config.get('mining', 'threads'))
        threads_spinbox = ttk.Spinbox(mining_frame, from_=1, to=max_threads, 
                                     textvariable=self.threads_var, width=10)
        threads_spinbox.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(mining_frame, text=f"Max: {max_threads} cores", 
                 foreground="gray").grid(row=0, column=2, sticky="w", padx=5)
        
        # NiceHash mode
        self.nicehash_var = tk.BooleanVar(value=self.config.getboolean('mining', 'nicehash_mode'))
        nicehash_check = ttk.Checkbutton(mining_frame, text="NiceHash kompatibilita", 
                                        variable=self.nicehash_var)
        nicehash_check.grid(row=1, column=0, columnspan=2, sticky="w", pady=5)
        
        # Preset buttons
        preset_frame = ttk.LabelFrame(config_frame, text="Pool Presets", padding=10)
        preset_frame.pack(fill="x", pady=5)
        
        ttk.Button(preset_frame, text="ZION Pool", 
                  command=self.set_zion_pool).pack(side="left", padx=5)
        ttk.Button(preset_frame, text="NiceHash RandomX", 
                  command=self.set_nicehash).pack(side="left", padx=5)
        ttk.Button(preset_frame, text="MineXMR", 
                  command=self.set_minexmr).pack(side="left", padx=5)
        ttk.Button(preset_frame, text="Ulo≈æit Config", 
                  command=self.save_current_config).pack(side="right", padx=5)
        
        # Temperature settings
        temp_config_frame = ttk.LabelFrame(config_frame, text="üå°Ô∏è Temperature Nastaven√≠", padding=10)
        temp_config_frame.pack(fill="x", pady=5)
        
        ttk.Label(temp_config_frame, text="Max bezpeƒçn√° teplota:").grid(row=0, column=0, sticky="w", pady=2)
        self.max_temp_var = tk.StringVar(value=self.config.get('mining', 'max_temp', fallback='85'))
        max_temp_spinbox = ttk.Spinbox(temp_config_frame, from_=60, to=95, 
                                      textvariable=self.max_temp_var, width=8)
        max_temp_spinbox.grid(row=0, column=1, padx=5, pady=2)
        ttk.Label(temp_config_frame, text="¬∞C (auto-stop p≈ôi p≈ôekroƒçen√≠)").grid(row=0, column=2, sticky="w")
        
        # Tab 2: Mining Control
        mining_tab = ttk.Frame(notebook)
        notebook.add(mining_tab, text="üî• Real Mining")
        
        # Control buttons
        control_frame = ttk.Frame(mining_tab)
        control_frame.pack(fill="x", pady=10)
        
        self.start_button = ttk.Button(control_frame, text="üöÄ Start REAL Mining", 
                                     command=self.start_mining)
        self.start_button.pack(side="left", padx=5)
        
        self.stop_button = ttk.Button(control_frame, text="‚èπÔ∏è Stop Mining", 
                                    command=self.stop_mining, state="disabled")
        self.stop_button.pack(side="left", padx=5)
        
        ttk.Button(control_frame, text="üîç Test Pool Connection", 
                  command=self.test_connection).pack(side="left", padx=5)
        
        # Temperature monitoring
        temp_frame = ttk.LabelFrame(mining_tab, text="üå°Ô∏è Temperature Monitor", padding=10)
        temp_frame.pack(fill="x", pady=5)
        
        temp_grid = ttk.Frame(temp_frame)
        temp_grid.pack(fill="x")
        
        ttk.Label(temp_grid, text="CPU Teplota:").grid(row=0, column=0, sticky="w", pady=2)
        self.cpu_temp_label = ttk.Label(temp_grid, text="N/A¬∞C", foreground="green")
        self.cpu_temp_label.grid(row=0, column=1, sticky="w", padx=10, pady=2)
        
        ttk.Label(temp_grid, text="Status:").grid(row=0, column=2, sticky="w", pady=2)
        self.temp_status_label = ttk.Label(temp_grid, text="üü¢ Teplota OK", foreground="green")
        self.temp_status_label.grid(row=0, column=3, sticky="w", padx=10, pady=2)
        
        # Real stats frame
        stats_frame = ttk.LabelFrame(mining_tab, text="Real Mining Stats", padding=10)
        stats_frame.pack(fill="x", pady=5)
        
        stats_grid = ttk.Frame(stats_frame)
        stats_grid.pack(fill="x")
        
        ttk.Label(stats_grid, text="Status:").grid(row=0, column=0, sticky="w", pady=2)
        self.status_label = ttk.Label(stats_grid, text="Vypnuto", foreground="red")
        self.status_label.grid(row=0, column=1, sticky="w", padx=10, pady=2)
        
        ttk.Label(stats_grid, text="Hashrate:").grid(row=0, column=2, sticky="w", pady=2)
        self.hashrate_label = ttk.Label(stats_grid, text="0 H/s")
        self.hashrate_label.grid(row=0, column=3, sticky="w", padx=10, pady=2)
        
        ttk.Label(stats_grid, text="Shares:").grid(row=1, column=0, sticky="w", pady=2)
        self.shares_label = ttk.Label(stats_grid, text="0/0")
        self.shares_label.grid(row=1, column=1, sticky="w", padx=10, pady=2)
        
        ttk.Label(stats_grid, text="Active Threads:").grid(row=1, column=2, sticky="w", pady=2)
        self.threads_label = ttk.Label(stats_grid, text="0")
        self.threads_label.grid(row=1, column=3, sticky="w", padx=10, pady=2)
        
        # Tab 3: Logs
        log_frame = ttk.Frame(notebook)
        notebook.add(log_frame, text="üìã Mining Logy")
        
        # Log controls
        log_controls = ttk.Frame(log_frame)
        log_controls.pack(fill="x", pady=5)
        
        ttk.Button(log_controls, text="Vymazat logy", 
                  command=self.clear_logs).pack(side="left", padx=5)
        ttk.Button(log_controls, text="Ulo≈æit logy", 
                  command=self.save_logs).pack(side="left", padx=5)
        
        # Log text area
        self.log_text = scrolledtext.ScrolledText(log_frame, height=20, font=("Consolas", 10))
        self.log_text.pack(fill="both", expand=True, pady=5)
        
        # Status bar
        self.status_bar = ttk.Label(self.window, text="Real Mining p≈ôipraven", relief="sunken")
        self.status_bar.pack(fill="x", side="bottom")
        
    def set_zion_pool(self):
        """Nastav√≠ ZION pool preset"""
        self.pool_host_var.set("91.98.122.165")
        self.pool_port_var.set("3333")
        self.nicehash_var.set(False)
        self.log_message("üìù Nastaven ZION Pool preset")
        
    def set_nicehash(self):
        """Nastav√≠ NiceHash preset"""
        self.pool_host_var.set("randomxmonero.auto.nicehash.com")
        self.pool_port_var.set("9200")
        self.nicehash_var.set(True)
        # Pro NiceHash pou≈æ√≠vej jen wallet adresu bez worker name
        self.log_message("üìù Nastaven NiceHash preset")
        self.log_message("‚ö†Ô∏è Nastav svou Monero adresu pro NiceHash!")
        
    def set_minexmr(self):
        """Nastav√≠ MineXMR preset"""
        self.pool_host_var.set("pool.minexmr.com")
        self.pool_port_var.set("4444")
        self.nicehash_var.set(False)
        self.log_message("üìù Nastaven MineXMR preset")
        
    def save_current_config(self):
        """Ulo≈æ√≠ aktu√°ln√≠ nastaven√≠"""
        self.config.set('mining', 'pool_host', self.pool_host_var.get())
        self.config.set('mining', 'pool_port', self.pool_port_var.get())
        self.config.set('mining', 'wallet_address', self.wallet_var.get())
        self.config.set('mining', 'worker_name', self.worker_var.get())
        self.config.set('mining', 'threads', self.threads_var.get())
        self.config.set('mining', 'nicehash_mode', str(self.nicehash_var.get()))
        self.config.set('mining', 'max_temp', self.max_temp_var.get())
        
        self.save_config()
        self.log_message("üíæ Konfigurace ulo≈æena")
        messagebox.showinfo("Ulo≈æeno", "Konfigurace byla √∫spƒõ≈°nƒõ ulo≈æena!")
        
    def get_cpu_temperature(self):
        """Z√≠sk√° aktu√°ln√≠ teplotu CPU"""
        try:
            # Pou≈æij sensors p≈ô√≠kaz
            result = subprocess.run(['sensors'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                # Hledej Tctl (AMD) nebo Core (Intel) teploty
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'Tctl:' in line or 'Package id 0:' in line:
                        # Extrahuj teplotu z ≈ô√°dku
                        match = re.search(r'([+-]?\d+\.?\d*)¬∞C', line)
                        if match:
                            return float(match.group(1))
                    elif line.startswith('Core') and '¬∞C' in line:
                        match = re.search(r'([+-]?\d+\.?\d*)¬∞C', line)
                        if match:
                            return float(match.group(1))
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è Chyba ƒçten√≠ teploty: {e}")
            
        return None
        
    def monitor_temperature(self):
        """Monitoruje teplotu CPU bƒõhem mining"""
        while self.mining:
            try:
                temp = self.get_cpu_temperature()
                if temp is not None:
                    self.cpu_temp = temp
                    max_temp = float(self.max_temp_var.get())
                    
                    # Aktualizuj GUI
                    self.window.after(0, lambda: self.update_temperature_display(temp, max_temp))
                    
                    # Kontrola p≈ôeh≈ô√°t√≠
                    if temp > max_temp:
                        self.window.after(0, lambda: self.handle_overheat(temp))
                        break
                        
                time.sleep(10)  # Kontrola ka≈æd√Ωch 10 sekund
            except Exception as e:
                break
                
    def update_temperature_display(self, temp, max_temp):
        """Aktualizuje zobrazen√≠ teploty v GUI"""
        if temp < max_temp - 15:
            color = "green"
            status = "üü¢ Teplota OK"
        elif temp < max_temp - 5:
            color = "orange" 
            status = "üü° Teplota zv√Ω≈°en√°"
        else:
            color = "red"
            status = "üî¥ NEBEZPEƒåN√Å TEPLOTA!"
            
        self.cpu_temp_label.config(text=f"{temp:.1f}¬∞C", foreground=color)
        self.temp_status_label.config(text=status, foreground=color)
        
    def handle_overheat(self, temp):
        """Zp≈Øsob√≠ p≈ôeh≈ô√°t√≠ CPU"""
        self.log_message(f"üî• P≈òEH≈ò√ÅT√ç! CPU: {temp:.1f}¬∞C")
        messagebox.showerror(
            "P≈ôeh≈ô√°t√≠ CPU!", 
            f"CPU dosahuje nebezpeƒçn√© teploty: {temp:.1f}¬∞C\n\n"
            "Mining bude automaticky zastaven!"
        )
        self.stop_mining()
        
    def log_message(self, message):
        """P≈ôid√° zpr√°vu do log≈Ø s ƒçasovou znaƒçkou"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        full_message = f"[{timestamp}] {message}\n"
        
        self.log_text.insert(tk.END, full_message)
        self.log_text.see(tk.END)
        
    def clear_logs(self):
        """Vyma≈æe logy"""
        self.log_text.delete(1.0, tk.END)
        self.log_message("üóëÔ∏è Logy vymaz√°ny")
        
    def save_logs(self):
        """Ulo≈æ√≠ logy do souboru"""
        filename = filedialog.asksaveasfilename(
            defaultextension=".log",
            filetypes=[("Log files", "*.log"), ("Text files", "*.txt"), ("All files", "*.*")],
            title="Ulo≈æit logy"
        )
        if filename:
            with open(filename, 'w') as f:
                f.write(self.log_text.get(1.0, tk.END))
            self.log_message(f"üíæ Logy ulo≈æeny do {filename}")
            
    def test_connection(self):
        """Testuje spojen√≠ s poolem"""
        def test():
            self.log_message(f"üîç Testov√°n√≠ spojen√≠ s {self.pool_host_var.get()}:{self.pool_port_var.get()}")
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((self.pool_host_var.get(), int(self.pool_port_var.get())))
                sock.close()
                
                if result == 0:
                    self.log_message("‚úÖ Spojen√≠ √∫spƒõ≈°n√©!")
                    messagebox.showinfo("Test spojen√≠", "Spojen√≠ s poolem je funkƒçn√≠!")
                else:
                    self.log_message("‚ùå Spojen√≠ selhalo!")
                    messagebox.showerror("Test spojen√≠", "Nepoda≈ôilo se p≈ôipojit k poolu!")
            except Exception as e:
                self.log_message(f"‚ùå Chyba testov√°n√≠: {e}")
                messagebox.showerror("Chyba", f"Chyba p≈ôi testov√°n√≠: {e}")
                
        threading.Thread(target=test, daemon=True).start()
        
    def start_mining(self):
        """Spust√≠ skuteƒçn√Ω mining"""
        if self.mining:
            return
            
        # Validate settings
        if not self.pool_host_var.get() or not self.pool_port_var.get():
            messagebox.showerror("Chyba", "Zadejte host a port poolu!")
            return
            
        if not self.wallet_var.get():
            messagebox.showerror("Chyba", "Zadejte wallet adresu!")
            return
            
        # Warning dialog pro real mining
        result = messagebox.askyesno(
            "REAL Mining Warning", 
            "Spustit skuteƒçn√Ω mining?\n\n"
            "‚ö†Ô∏è UPOZORNƒöN√ç:\n"
            "‚Ä¢ 100% CPU zat√≠≈æen√≠\n"
            "‚Ä¢ Vysok√° spot≈ôeba elekt≈ôiny\n" 
            "‚Ä¢ Mo≈æn√© p≈ôeh≈ô√°t√≠ CPU\n"
            "‚Ä¢ Zpomalen√≠ syst√©mu\n"
            "‚Ä¢ Temperature monitoring aktivn√≠\n\n"
            "Pokraƒçovat?",
            icon="warning"
        )
        
        if not result:
            return
            
        self.mining = True
        self.shares_submitted = 0
        self.shares_accepted = 0
        self.start_time = time.time()
        
        # Update UI
        self.start_button.config(state="disabled")
        self.stop_button.config(state="disabled")  # Zak√°z√°no a≈æ do p≈ôipojen√≠
        self.status_label.config(text="P≈ôipojov√°n√≠...", foreground="orange")
        
        # Initialize miners
        num_threads = int(self.threads_var.get())
        self.miners = []
        for i in range(num_threads):
            miner = RandomXMiner()
            self.miners.append(miner)
            
        self.threads_label.config(text=str(num_threads))
        
        # Save current config
        self.save_current_config()
        
        # Start mining thread
        connection_thread = threading.Thread(target=self.mining_worker, daemon=True)
        connection_thread.start()
        
        # Start temperature monitoring
        temp_thread = threading.Thread(target=self.monitor_temperature, daemon=True)
        temp_thread.start()
        
        self.log_message(f"üöÄ REAL Mining spu≈°tƒõn s {num_threads} threads!")
        self.log_message("‚ö†Ô∏è CPU bude 100% vyt√≠≈æeno!")
        self.log_message("üå°Ô∏è Temperature monitoring aktivn√≠")
        
    def stop_mining(self):
        """Zastav√≠ mining"""
        self.mining = False
        
        # Stop all miners
        for miner in self.miners:
            miner.mining = False
            
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
            self.socket = None
            
        # Update UI
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        self.status_label.config(text="Zastaveno", foreground="red")
        
        self.log_message("‚èπÔ∏è REAL Mining zastaven!")
        
    def mining_worker(self):
        """Hlavn√≠ mining worker thread"""
        try:
            # Connect to pool
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(30)
            self.socket.connect((self.pool_host_var.get(), int(self.pool_port_var.get())))
            
            self.log_message(f"‚úÖ P≈ôipojen k {self.pool_host_var.get()}:{self.pool_port_var.get()}")
            self.status_label.config(text="P≈ôipojen", foreground="green")
            self.stop_button.config(state="normal")
            
            # Subscribe to mining
            subscribe_msg = {
                "id": 1,
                "method": "mining.subscribe",
                "params": ["zion-real-miner/1.4.0"]
            }
            
            self.send_stratum_message(subscribe_msg)
            
            # Authorize worker
            if self.nicehash_var.get():
                # NiceHash pou≈æ√≠v√° jen wallet adresu
                username = self.wallet_var.get()
                self.log_message("üîó NiceHash mode: pou≈æ√≠v√°m pouze wallet adresu")
            else:
                # Standardn√≠ pooly pou≈æ√≠vaj√≠ wallet.worker
                username = f"{self.wallet_var.get()}.{self.worker_var.get()}"
                
            auth_msg = {
                "id": 2,
                "method": "mining.authorize",
                "params": [username, "x"]
            }
            
            self.send_stratum_message(auth_msg)
            
            # Main communication loop
            while self.mining and self.socket:
                try:
                    response = self.socket.recv(4096).decode('utf-8').strip()
                    if response:
                        for line in response.split('\n'):
                            if line.strip():
                                self.handle_stratum_message(line.strip())
                except socket.timeout:
                    continue
                except Exception as e:
                    if self.mining:
                        self.log_message(f"‚ùå Chyba p≈ô√≠jmu: {e}")
                    break
                    
        except Exception as e:
            self.log_message(f"‚ùå Chyba p≈ôipojen√≠: {e}")
            messagebox.showerror("Chyba p≈ôipojen√≠", str(e))
        finally:
            if self.mining:
                self.window.after(0, self.stop_mining)
                
    def send_stratum_message(self, message):
        """Po≈°le Stratum zpr√°vu"""
        if self.socket:
            msg = json.dumps(message) + '\n'
            self.socket.send(msg.encode('utf-8'))
            self.log_message(f"üì§ Odesl√°no: {message['method']}")
            
    def handle_stratum_message(self, message):
        """Zpracuje p≈ô√≠choz√≠ Stratum zpr√°vu"""
        try:
            data = json.loads(message)
            
            if 'method' in data:
                if data['method'] == 'mining.notify':
                    self.handle_job_notification(data)
                elif data['method'] == 'mining.set_difficulty':
                    self.handle_difficulty_change(data)
            elif 'result' in data:
                if data['id'] == 1:  # Subscribe response
                    self.handle_subscribe_response(data)
                elif data['id'] == 2:  # Auth response
                    self.handle_auth_response(data)
                else:  # Share response
                    self.handle_share_response(data)
                    
        except json.JSONDecodeError as e:
            self.log_message(f"‚ö†Ô∏è Neplatn√© JSON: {e}")
            
    def handle_subscribe_response(self, data):
        """Zpracuje odpovƒõƒè na subscribe"""
        if data['result']:
            self.extranonce1 = data['result'][1]
            self.extranonce2_size = data['result'][2]
            self.log_message("‚úÖ Subscribe √∫spƒõ≈°n√Ω")
            
    def handle_auth_response(self, data):
        """Zpracuje odpovƒõƒè na autorizaci"""
        if data['result']:
            pool_type = "NiceHash" if self.nicehash_var.get() else "Standard Pool"
            self.log_message(f"‚úÖ Autorizace √∫spƒõ≈°n√° ({pool_type}) - REAL mining m≈Ø≈æe zaƒç√≠t!")
            self.status_label.config(text="Autorizov√°n - Mining aktivn√≠", foreground="green")
        else:
            self.log_message("‚ùå Autorizace selhala!")
            
    def handle_job_notification(self, data):
        """Zpracuje nov√Ω mining job a spust√≠ skuteƒçn√Ω mining"""
        params = data['params']
        self.job_id = params[0]
        self.blob = params[1] if len(params) > 1 else ""
        self.target = params[6] if len(params) > 6 else "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        
        self.log_message(f"‚ö° Nov√Ω REAL job: {self.job_id}")
        self.log_message(f"üéØ Target: {self.target[:16]}...")
        
        # Spustit skuteƒçn√Ω mining na v≈°ech threads
        self.start_real_mining()
        
    def start_real_mining(self):
        """Spust√≠ skuteƒçn√Ω CPU-intensive RandomX mining na v≈°ech threads"""
        if not self.blob or not self.job_id:
            return
            
        job_data = {
            'blob': self.blob,
            'target': self.target,
            'job_id': self.job_id
        }
        
        # Vyƒçisti star√© threads
        self.worker_threads.clear()
        
        # Spustit mining na ka≈æd√©m thread s CPU affinity
        for i, miner in enumerate(self.miners):
            def mine_thread(miner_instance, thread_id):
                self.log_message(f"üöÄ Thread {thread_id} zaƒç√≠n√° SKUTEƒåN√â hashov√°n√≠...")
                
                # Nastav thread priority pro CPU mining
                try:
                    os.nice(0)  # Normal priority pro mining
                except:
                    pass
                
                # Spustit CPU-intensive mining
                result = miner_instance.mine_block(job_data, self.on_share_found)
                
                if result:
                    self.log_message(f"üíé Thread {thread_id} na≈°el share!")
                else:
                    self.log_message(f"‚èπÔ∏è Thread {thread_id} zastaven")
                
            thread = threading.Thread(target=mine_thread, args=(miner, i), daemon=True)
            thread.start()
            self.worker_threads.append(thread)
            
        self.log_message(f"üî• REAL CPU-intensive mining spu≈°tƒõn na {len(self.miners)} threads!")
        self.log_message(f"‚ö° Ka≈æd√Ω thread hashuje ~500-1000 H/s (CPU z√°visl√©)")
        self.log_message(f"üå°Ô∏è Monitor teploty aktivn√≠ - auto-stop p≈ôi {self.max_temp_var.get()}¬∞C")
        
    def on_share_found(self, result):
        """Callback kdy≈æ je nalezena platn√° share"""
        if not self.mining:
            return
            
        self.log_message(f"üíé SHARE NALEZEN! Nonce: {result['nonce']}")
        
        # P≈ôiprav username podle typu poolu
        if self.nicehash_var.get():
            username = self.wallet_var.get()  # NiceHash
        else:
            username = f"{self.wallet_var.get()}.{self.worker_var.get()}"  # Standardn√≠ pool
        
        # Odeslat share na pool
        share_msg = {
            "id": 100 + self.shares_submitted,
            "method": "mining.submit",
            "params": [
                username,
                self.job_id,
                "00000000",  # extranonce2
                str(int(time.time())),  # ntime
                result['nonce']
            ]
        }
        
        self.send_stratum_message(share_msg)
        self.shares_submitted += 1
        
    def handle_share_response(self, data):
        """Zpracuje odpovƒõƒè na share"""
        if data.get('result', False):
            self.shares_accepted += 1
            self.log_message("‚úÖ SHARE P≈òIJAT na poolu!")
        else:
            error = data.get('error', ['Nezn√°m√° chyba'])[1] if data.get('error') else 'Nezn√°m√° chyba'
            self.log_message(f"‚ùå Share odm√≠tnut: {error}")
            
    def handle_difficulty_change(self, data):
        """Zpracuje zmƒõnu obt√≠≈ænosti"""
        difficulty = data['params'][0]
        self.log_message(f"üìä Obt√≠≈ænost zmƒõnƒõna na: {difficulty}")
        
    def update_stats(self):
        """Aktualizuje statistiky v GUI s real-time monitoring"""
        if self.mining and self.start_time:
            # Calculate total hashrate from all active miners
            total_hashrate = 0
            active_miners = 0
            
            for miner in self.miners:
                if miner.mining and miner.hashrate > 0:
                    total_hashrate += miner.hashrate
                    active_miners += 1
            
            self.total_hashrate = total_hashrate
            
            # Update GUI labels
            uptime = time.time() - self.start_time
            hours = int(uptime // 3600)
            minutes = int((uptime % 3600) // 60)
            seconds = int(uptime % 60)
            
            # Format hashrate with proper units
            if total_hashrate > 1000:
                hashrate_display = f"{total_hashrate/1000:.1f} KH/s"
            else:
                hashrate_display = f"{total_hashrate:.0f} H/s"
                
            self.hashrate_label.config(text=hashrate_display)
            self.shares_label.config(text=f"{self.shares_accepted}/{self.shares_submitted}")
            self.threads_label.config(text=f"{active_miners}/{len(self.miners)}")
            
            # Status bar s detailn√≠mi informacemi
            if self.shares_submitted > 0:
                acceptance_rate = (self.shares_accepted / self.shares_submitted) * 100
                pool_type = "NiceHash" if self.nicehash_var.get() else "Pool"
                temp_str = f" | CPU: {self.cpu_temp:.1f}¬∞C" if self.cpu_temp > 0 else ""
                uptime_str = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
                self.status_bar.config(text=f"REAL Mining ({pool_type}) | {hashrate_display} | {acceptance_rate:.1f}% success | {uptime_str}{temp_str}")
            else:
                temp_str = f" | CPU: {self.cpu_temp:.1f}¬∞C" if self.cpu_temp > 0 else ""
                self.status_bar.config(text=f"CPU Mining Active | {hashrate_display} | Searching for shares...{temp_str}")
        else:
            self.status_bar.config(text="REAL Mining p≈ôipraven - CPU bude 100% vyu≈æito!")
            
        # Schedule next update
        self.window.after(2000, self.update_stats)  # 2s interval pro lep≈°√≠ performance
        
    def run(self):
        """Spust√≠ aplikaci"""
        self.log_message("üåü ZION REAL Miner 1.4.0 spu≈°tƒõn")
        self.log_message("‚ö†Ô∏è SKUTEƒåN√ù MINING - spot≈ôebov√°v√° CPU a elekt≈ôinu!")
        self.log_message("üî• RandomX algoritmus pro ZION/Monero")
        self.log_message("üå°Ô∏è Temperature monitoring integrov√°n")
        self.log_message("üí° NiceHash podporov√°n (zapni checkbox)")
        
        # Test initial temperature reading
        temp = self.get_cpu_temperature()
        if temp:
            self.log_message(f"üå°Ô∏è Aktu√°ln√≠ CPU teplota: {temp:.1f}¬∞C")
        else:
            self.log_message("‚ö†Ô∏è Nepoda≈ôilo se naƒç√≠st teplotu CPU (spus≈• 'sudo sensors-detect')")
            
        self.window.mainloop()

if __name__ == "__main__":
    try:
        import tkinter as tk
        from tkinter import ttk
        
        # Spu≈°tƒõn√≠ real mining aplikace
        miner = ZionRealMiner()
        miner.run()
        
    except ImportError:
        print("‚ùå Chyba: tkinter nen√≠ nainstalov√°n!")
        print("üí° Nainstalujte: sudo apt-get install python3-tk")
    except Exception as e:
        print(f"‚ùå Chyba spu≈°tƒõn√≠: {e}")